---
title: "Knowledge C_Data_Scientist_Toolbox"
author: "Sjoerd Gnodde"
date: "26 februari 2019"
output: html_document
---

# Get help

```{r}
# ?rnorm

# help.search('rnorm')

# args('rnorm')

# rnorm
```


```{r}
con <- url("http://jhsph.edu", "r")
x <- readLines(con)
head(x)
```
## Types of data analysis
* Descriptive
* Exploratory
* Inferential
* Predictive
* Causal
* Mechanisic

## Share
* github
* figshare
* https://github.com/jtleek/datasharing

## Confounding
An external reason explains both data sets

Corrolation is not causation

## Put people into random groups

## Errors
* True positive
* True negative
* False positive
* False negative

## Quantities
* Sensitivity (P(positive test|disease))
* Specificivity (P(negative test|no disease))
* Positive predictive value (P(disease|positive test))
* Negative predictive value (P(no disease|negative test))
* Accuracy (P(Correct outcome))

## Data dredging
Too long looking for significant result


# R programming

## Programming in RGui

Set working directory:
File -> Change dir

Get working directory:
```{r}
getwd()
```

## Data types

### Vectors

```{r}
x <- c(0.5, 0.6)
x1 <- c(T,F) #True, FAlse
x2 <- c(TRUE, FALSE)
x3 <- 9:30
x4 <- vector("numeric", length = 10)
```
Mixing will end up to 1 type

```{r}
x5 <- as.character(x)
```

### List
Can be different items

```{r}
x6 <- list(1, "a", TRUE, 1.1)
```

### Matrices
Vector with a dimension

```{r}
matrix(nrow = 5, ncol = 3)
a <- 1:3
b <- 10:12
x7 <- cbind(a,b)
x8 <- rbind(a,b)
```

### Factors
Categorical data
```{r}
x9 <- factor(c("yes", "no", "yes","yes", "no"))
x9
table(x9)
unclass(x9)
attr(x9, "levels")
factor(c("yes", "no", "yes","yes", "no"), levels=c("yes", "no"))
```

### Missing Values

```{r}
lst1 <- c(1, NA, NaN)
is.na(lst1)
is.nan(lst1) # also misses what it should be
```
nan is na, but na is not necessarily nan

### Data Frames
Can store different types per column

Attribute called ```row.names```

Call with ```read.table()``` or ```read.csv()``` or ```data.frame()```

Convert to matrix with ```data.matrix()```

```{r}
x10 <- data.frame(foo = 1:4, bar = c(T, F, F, T))
x10
nrow(x10)
ncol(x10)
```

### Names attribute

```{r}
x11 <- 1:3
names(x11) <- c("foo", "bar", "norf")
x11

x12 <- list(a=1, b=2, c=3)
x12

x13 <- matrix(1:4, nrow=2, ncol=2)
dimnames(x13) <- list(c("a", "b"), c("c", "d"))
x13
```

### Reading Tabular Data

```{r}
# read.table(), read.csv() [see docstring]
# readLines()
# source()
# dget()
# load()
# unserialize()
```

### Writing data

```{r}
# write.table()
# writeLines()
# dump()
# dput()
# save()
# serialize()
```


### Large datasets
For example: first read first 100 lines, then use these classes.
```{r}
# set.comment = ""
```
2^20 bytes/mb

about twice the amount data needed to load it


```dput``` reconstructs

```dump``` slightly different


### Interfaces to the outside world

```{r}
# file -> opens a connection to a file
# gqfile -> connection to gzip
# bzfile -> connection to bzip2
# url opens webpage

# con <- file("foo.txt", "r")
# data <- read.csv(con)
# close(con)

# same as just read.csv("foo.txt")
```

### Subsetting

```[]``` subsets same class

```[[]]``` extract elements (single)

```$``` extract by name

```{r}
x13 <- c("a", "b", "c")
x13[2]
x13[2:3]
x13[x13>"a"]
x14 <- x13 > "a"
x14
```

Subsetting lists
```{r}
x15 <- list(foo=1:4, bar=0.7)
x15[1]
x15[[1]]
x15$bar
x15["bar"]
x15[["bar"]]
x15[c(1,2)]
name <- "bar"
x15[[name]]
```

Further subsetting lists
```{r}
x16 <- list(a = list(10, 11,12), b = c(3.14, 1.71))
x16[[c(1,3)]]
x16[[1]][[3]]
```

Matrices exactly as expected. First row, then column. 

```{r}
# x[1, ] # is the complete first row
```

By setting drop=False one can get a matrix back instead of a vector

Partial matching
```{r}
x17 <- list(aardvark = 1:5)
x17$a
x17[["a"]]
x17[["a", exact = FALSE]]
``` 
Removing NA values

```{r}
x18 <- c(1, 2, NA, NA, 5)
bad <- is.na(x18)
x18[!bad]

# both
# good <- complete.cases(x,y)

# remove rows with nans
# good <- complete.cases(data)
# data[good, ][1:6, ]
```

### Matrix multiplication

```*```, ```/``` element wise

```%*%``` matrix multiplication

# Control Structures

### If else
```{r}
x19 <- 1
if(x19>1){
print('x19>0')
} else if(x19==1){
print('x19=1')
} else{
print('x19<=0')
}


x20 <- if(x19==1){
  2
} else{
  1
}
x20
```

### For loops

```{r}
for(i in 1:5){
  print(i)
}

x21 <- c("a", "b", "c", "d")
for(i in 1:4){
  print(x21[i])
}

for(i in seq_along(x21)){
  print(x21[i])
}

for(letter in x21){
  print(letter)
}

for(i in 1:4) print(x21[i])
```

### Nested for loop
```{r}
x22 <- matrix(1:6, 2, 3)

for(i in seq_len(nrow(x22))){
  for(j in seq_len(ncol(x22))){
    print(x22[i,j])
  }
}
```

### Why loop
```{r}
count <- 0
while(count<6){
  print(count)
  count <- count + 1
}
```
R checks conditions from left to right

### Repeat
Repeat until break

### Next
Go to the next repeat in the loop. For example in for loop. 
```{r}

for(i in 1:9){
  if(i==5 | i ==7){
    next
  }
  print(i)
}
```

### Return
Exits function

### First R function
```{r}
columnmean <- function(y, removeNA = TRUE){
  nc <- ncol(y)
  means <- numeric(nc)
  for(i in 1:nc){
    means[i] <- mean(y[, i], na.rm = removeNA)
  }
  means
}
```

### Lazy evaluation
If necessary argument in function is not used, no error is output.
```{r}
f1 <- function(a,b){
  print(a)
}
f1("Hello World")
```

### ... Argument
For example when you call a plot function in your function. Absorbs all arguments in ... and passes it on to ... in other function. 
```{r}
myplot <- function(x,y, type = "l", ...){
  plot(x, y, type = type, ...)
}
```
Can also be used for _generic functions_

Or for unknown number of argumens
```{r}
args(paste)
args(cat)
``` 
Positional argumenting not possible anymore after this.

### Scoping rules - Symbol binding
_Double defined_
R searches for environment
* Global environment (user workspace)
* Other packages

Users can load packages into the workspace. Namespace get moved into second postion, after Global Environment. 

#### Free variable
_The values of free variables are searched for in the environment in which the function was defined_
If it does not find it, it goes to the next parent.
Parents and children of environments. Every environment has one parent. Top environment is global environment or namespace of package.

### Function in function
```{r}
make.power <- function(n){
  pow <- function(x){
    x^n
  }
  pow
}

cube <- make.power(3)
square <- make.power(2)
cube(3)
square(3)

ls(environment(cube))
get("n", environment(cube))
```
R calls value from where it is defined, not from where it is _called_. 

## Coding standards
* indent
* max width
* basic formulae: make more, smaller formulae

## Date and times
Dates are stored internally as the number of seconds since `1970-01-01`
Times are stored internally as the number of seconds since `1970-01-01`
```{r}
x23 <- Sys.time()
x24 <- as.POSIXlt(x23)
names(unclass(x24))

datestring <- c("November 9, 2011 9:10", "December 9, 2011 9:10")
x25 <- strptime(datestring, "%B %d, %Y %H:%M")
x25
class(x25)
```
Recognises difference in time zones.
Plot recognises `datetime` objects.

## Loop Functions
### lapply
Loop over a list and evaluate a function on each element. `lapply` takes three arguments: (1) a list X; (2) a function (or the name of a function) FUN; (3) other arguments via its ... argument. If X is not a list, it will be coerced to a list using as.list.
```{r}
#help(lapply)

x25 <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x25, mean)

# Anonymous functions
x26 <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
lapply(x26, function(elt) elt[,1])
```
### sapply
Tries to simplify results. For example if every object in list has length 1, returns vector. All same length > 1, returns matrix.

### apply
It writes shorter than for loop, but is not faster. 

`function (X, MARGIN, FUN, ...)`
* X is an array
* MARGIN is an integer vector indicating which margins should be "retained".
* FUN is a function to be applied
* ... is for other arguments to be passed to FUN
```{r}
#str(apply)
x27 <- matrix(rnorm(50), 10, 5)
apply(x27, 2, mean) # mean over the columns
apply(x27, 1, sum) # sum over the rows
``` 

These already exist in 
```{r}
rowSums(x27)
rowMeans(x27)
colSums(x27)
colMeans(x27)
```

```{r}
apply(x27, 1, quantile, probs = c(0.05, 0.95))
```

### mapply

Multivariate: multiple list arguments
```{r}
noise <- function(n, mean, sd){
  rnorm(n, mean, sd)
}

mapply(noise, 1:5, 5:1, 2)
```

### tapply
For vectors with same length
```{r}
x28 <- c(rnorm(10), runif(10), rnorm(10))
f <- gl(3,10)
tapply(x28, f, mean)
``` 

## split
Splitting arbitrary dataframes
```{r}
x29 <- rnorm(10)
f1 <- gl(2,5)
f2 <- gl(5,2)
interaction(f1, f2)
split(x29, list(f1,f2))
split(x29, list(f1,f2), drop=TRUE)

```

## Debugging

* message: A generic notification/diagnostic message produced by the message function; execution of the function continues
* warning: An indication that something is wrong but not necessarily fatal; execution of the function continues; generated by the warning function
* error: An indication that a fatal problem has occurred; execution stops; produced by the stop function
* condition: A generic concept for indicating that something unexpected can occur; programmers can create their own conditions
